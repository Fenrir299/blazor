@page "/content-declination"
@using FFB.ContentTransformation.Data.Entities
@using FFB.ContentTransformation.Models
@using FFB.ContentTransformation.Services.DocumentProcessing
@using FFB.ContentTransformation.Services.AI.ContentGeneration
@using FFB.ContentTransformation.Services.ErrorHandling
@inject IDocumentProcessingService DocumentProcessingService
@inject IContentGenerationService ContentGenerationService
@inject IErrorHandlingService ErrorHandlingService
@rendermode Microsoft.AspNetCore.Components.Web.RenderMode.InteractiveServer
<PageTitle>Déclinaison de contenu - FFB POC</PageTitle>

<h2>Déclinaison de contenu</h2>
<p>Chargez un document et générez différents types de contenus adaptés à vos besoins.</p>

<FluentDivider></FluentDivider>

<div class="content-declination-container">
    <div class="file-upload-section">
        <h3>1. Chargez vos documents</h3>
        <FileUploader OnDocumentUploaded="HandleDocumentUploaded" />

        @if (Model.UploadedDocuments.Any())
        {
            <div class="mt-4">
                <MultiDocumentSelector Documents="@Model.UploadedDocuments" Model="@Model"
                    OnSelectionChanged="HandleDocumentSelectionChanged" />
            </div>
        }
    </div>

    @if (Model.SelectedDocuments.Any())
    {
        <div class="content-generation-section">
            <h3>2. Configurez la génération</h3>
            <ContentGenerationOptionsComponent Model="@Model" OnOptionsChanged="HandleOptionsChanged" />

            <div class="mt-4">
                <FluentButton Appearance="Appearance.Accent" OnClick="GenerateContent" Disabled="@Model.IsProcessing">
                    @if (Model.IsProcessing)
                    {
                        <FluentProgressRing />
                        <span class="ms-2">Génération en cours...</span>
                    }
                    else
                    {
                        <span>Générer le contenu</span>
                    }
                </FluentButton>
            </div>

            @if (!string.IsNullOrEmpty(Model.GeneratedContent))
            {
                <div class="mt-4">
                    <h3>3. Contenu généré</h3>
                    <GeneratedContentDisplay Content="@Model.GeneratedContent" ContentType="@Model.SelectedContentType" />
                </div>
            }

            @if (!string.IsNullOrEmpty(Model.ErrorMessage))
            {
                <FluentMessageBar class="mt-3">
                    @Model.ErrorMessage
                </FluentMessageBar>
            }
        </div>
    }
</div>

@code {
    private ContentDeclinationModel Model { get; set; } = new();

    protected override async Task OnInitializedAsync()
    {
        await LoadDocumentsAsync();
    }

    private async Task LoadDocumentsAsync()
    {
        try
        {
            // Dans une application réelle, on chargerait les documents depuis la base de données
            // Pour l'instant, on va simplement initialiser une liste vide
            Model.UploadedDocuments = new List<Document>();
        }
        catch (Exception ex)
        {
            Model.ErrorMessage = $"Erreur lors du chargement des documents: {ex.Message}";
        }
    }

    private async Task HandleDocumentUploaded(Document document)
    {
        Model.UploadedDocuments.Add(document);
        StateHasChanged();
    }

    private void HandleDocumentSelectionChanged()
    {
        // Reset generated content when selection changes
        Model.GeneratedContent = null;
        Model.ErrorMessage = null;
        StateHasChanged();
    }

    private void HandleOptionsChanged()
    {
        // Reset generated content when options change
        Model.GeneratedContent = null;
        StateHasChanged();
    }

    private async Task GenerateContent()
    {
        if (!Model.SelectedDocuments.Any())
        {
            Model.ErrorMessage = "Veuillez sélectionner au moins un document.";
            return;
        }

        Model.IsProcessing = true;
        Model.ErrorMessage = null;
        StateHasChanged();

        var options = new ContentGenerationOptions
        {
            ContentType = Model.SelectedContentType,
            Format = Model.SelectedFormat,
            CustomPrompt = Model.CustomPrompt,
            DocumentIds = Model.SelectedDocumentIds,
            UseChunking = Model.UseChunking,
            MultiDocStrategy = Model.MultiDocStrategy
        };

        // Utiliser le service de gestion des erreurs pour la génération de contenu
        var generationResult = await ErrorHandlingService.ExecuteAsync(
        async () =>
        {
            if (Model.SelectedDocuments.Count == 1)
            {
                return await ContentGenerationService.GenerateContentAsync(Model.SelectedDocuments[0], options);
            }
            else
            {
                return await ContentGenerationService.GenerateContentAsync(Model.SelectedDocuments, options);
            }
        },
        "content_generation"
        );

        if (generationResult.IsSuccess && generationResult.Data != null)
        {
            Model.GeneratedContent = generationResult.Data;

            // Sauvegarder le contenu généré
            var saveResult = await ErrorHandlingService.ExecuteAsync(
            async () =>
            {
                if (Model.SelectedDocuments.Count == 1)
                {
                    return await ContentGenerationService.SaveGeneratedContentAsync(
        Model.SelectedDocuments[0],
        Model.GeneratedContent,
        options
        );
                }
                else
                {
                    return await ContentGenerationService.SaveGeneratedContentAsync(
        Model.SelectedDocuments,
        Model.GeneratedContent,
        options
        );
                }
            },
            "save_generated_content"
            );

            if (!saveResult.IsSuccess)
            {
                // Afficher un avertissement si la sauvegarde a échoué, mais ne pas bloquer l'affichage du contenu
                Model.ErrorMessage = $"Le contenu a été généré mais n'a pas pu être sauvegardé: {saveResult.ErrorMessage}";
            }
        }
        else
        {
            Model.ErrorMessage = generationResult.ErrorMessage ?? "Une erreur inconnue s'est produite lors de la génération.";
        }

        Model.IsProcessing = false;
        StateHasChanged();
    }

    private string FormatFileSize(long bytes)
    {
        string[] sizes = { "B", "KB", "MB", "GB" };
        int order = 0;
        double size = bytes;

        while (size >= 1024 && order < sizes.Length - 1)
        {
            order++;
            size /= 1024;
        }

        return $"{size:0.##} {sizes[order]}";
    }

    private string GetProcessingStatus(Document document)
    {
        if (!document.ProcessingComplete && string.IsNullOrEmpty(document.ProcessingError))
            return "En cours de traitement...";

        if (!string.IsNullOrEmpty(document.ProcessingError))
            return $"Erreur: {document.ProcessingError}";

        return "Prêt";
    }
}

<style>
    .content-declination-container {
        display: flex;
        flex-direction: column;
        gap: 30px;
    }

    .file-upload-section,
    .content-generation-section {
        padding: 20px;
        background-color: #f9f9f9;
        border-radius: 5px;
    }

    .documents-grid {
        width: 100%;
        margin-top: 10px;
    }

    .mt-4 {
        margin-top: 1rem;
    }

    .ms-2 {
        margin-left: 0.5rem;
    }

    .mt-3 {
        margin-top: 0.75rem;
    }
</style>